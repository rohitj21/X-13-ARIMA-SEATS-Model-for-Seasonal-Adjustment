# Determine the start and end dates for the month
start_date <- as.Date(paste(year, month, "01", sep = "-"))
# Handle December we transition to the next year
if (month == 12) {
end_date <- as.Date(paste(year + 1, "01", "01", sep = "-")) - 1
} else {
end_date <- as.Date(paste(year, month + 1, "01", sep = "-")) - 1
}
dates <- seq.Date(start_date, end_date, by = "day")
# Calculate the number of each weekday in the month
mondays <- sum(weekdays(dates) == "Monday")
tuesdays <- sum(weekdays(dates) == "Tuesday")
wednesdays <- sum(weekdays(dates) == "Wednesday")
thursdays <- sum(weekdays(dates) == "Thursday")
fridays <- sum(weekdays(dates) == "Friday")
saturdays <- sum(weekdays(dates) == "Saturday")
sundays <- sum(weekdays(dates) == "Sunday")
results[month] <- (mondays + tuesdays + wednesdays + thursdays + fridays) - (5/2) * (saturdays + sundays)
}
return(results)
}
month_values1949 <- calculate_td_values(1949)
month_values1950 <- calculate_td_values(1950)
month_values1951 <- calculate_td_values(1951)
month_values1952 <- calculate_td_values(1952)
print(month_values1949)
print(month_values1950)
print(month_values1951)
print(month_values1952)
Xreg = matrix(c(trading_day_regressors[1:144], x_easter[1:144]), ncol = 2)
pretest0 <- arima(y,  order = c(0,1,1), seasonal = c(0,1,1))
pretest <- arima(y,xreg = Xreg,  order = c(0,1,1), seasonal = c(0,1,1))
print(pretest0)
print(pretest)
# Initial model with regressors (Easter and trading day effects)
model_with_regressors <- arima(y, xreg = Xreg, order = c(0,1,1), seasonal = c(0,1,1), method = 'ML')
# Calculate standardized residuals
residuals <- residuals(model_with_regressors)
std_residuals <- residuals / sqrt(model_with_regressors$sigma2)
# Plot standardized residuals
plot(std_residuals, type = 'o', main = "Standardized Residuals", xlab = "Time", ylab = "Standardized Residuals")
abline(h = c(-3, 3), col = "red")
# Identify outliers (standardized residuals > 3 in absolute value)
outliers <- which(abs(std_residuals) > 3)
if(length(outliers) > 0){
cat("Outliers detected at positions:\n")
for (idx in outliers) {
year <- floor(time(y)[idx])
month_index <- cycle(y)[idx]
month_name <- month.abb[month_index]
cat(sprintf("Time: %d %s, Residual: %f\n", year, month_name, std_residuals[idx]))
}
} else {
cat("No outliers detected.\n")
}
# Function to create outlier regressors
create_outlier_regressors <- function(y, idx) {
n <- length(y)
AO <- rep(0, n)
AO[idx] <- 1
LS <- rep(0, n)
LS[idx:n] <- 1
TC <- rep(0, n)
decay <- 0.7
TC[idx:n] <- decay^(0:(n - idx))
return(list(AO = AO, LS = LS, TC = TC))
}
# Function to select best outlier type based on AIC
select_best_outlier <- function(y, Xreg, idx) {
outlier_regs <- create_outlier_regressors(y, idx)
AIC_values <- c()
models <- list()
for (type in names(outlier_regs)) {
Xreg_new <- cbind(Xreg, outlier_regs[[type]])
colnames(Xreg_new)[ncol(Xreg_new)] <-paste0( type,floor(time(y)[idx]), ".", month.abb[cycle(y)[idx]])
model <- arima(y, xreg = Xreg_new, order = c(0,1,1), seasonal = c(0,1,1), method = 'ML')
AIC_values[type] <- AIC(model)
models[[type]] <- model
}
best_type <- names(which.min(AIC_values))
best_model <- models[[best_type]]
best_regressor <- outlier_regs[[best_type]]
return(list(type = best_type, model = best_model, regressor = best_regressor))
}
# Initialize variables
Xreg_current <- Xreg
outlier_positions <- outliers
outlier_types <- c()
iteration <- 1
threshhold <- 3
# Iterative outlier detection and correction
while(length(outlier_positions) > 0) {
print(paste("Iteration", iteration))
# Get the position of the largest outlier
idx <- outlier_positions[which.max(abs(std_residuals[outlier_positions]))]
year <- floor(time(y)[idx])
month_index <- cycle(y)[idx]
month_name <- month.abb[month_index]
print(paste("Processing outlier at time", year, month_name))
# Select best outlier type
best_outlier <- select_best_outlier(y, Xreg_current, idx)
best_type <- best_outlier$type
best_model <- best_outlier$model
best_regressor <- best_outlier$regressor
print(paste("Selected outlier type:", best_type))
# Update regressors
Xreg_current <- cbind(Xreg_current, best_regressor)
colnames(Xreg_current)[ncol(Xreg_current)] <- paste0(best_type,floor(time(y)[idx]), ".", month.abb[cycle(y)[idx]])
outlier_types <- c(outlier_types, paste0(best_type,floor(time(y)[idx]), ".", month.abb[cycle(y)[idx]]))
# Recalculate standardized residuals
residuals <- residuals(best_model)
std_residuals <- residuals / sqrt(best_model$sigma2)
# Plot standardized residuals
plot(std_residuals, type = 'o', main = paste("Standardized Residuals after iteration ", iteration), xlab = "Time", ylab = "Standardized Residuals")
abline(h = c(-threshhold, threshhold), col = "red")
# Identify outliers
outlier_positions <- which(abs(std_residuals) > threshhold)
outlier_positions <- setdiff(outlier_positions, idx)  # Exclude already processed outlier
if(length(outlier_positions) > 0){
print("Outliers detected at positions:")
for (idx_new in outlier_positions) {
year_new <- floor(time(y)[idx_new])
month_index_new <- cycle(y)[idx_new]
month_name_new <- month.abb[month_index_new]
print(paste("Time:", year_new, month_name_new, "Residual:", std_residuals[idx_new]))
}
} else {
print("No more outliers detected.")
}
iteration <- iteration + 1
}
# Final model
final_model <- best_model
summary(final_model)
# Final model
final_model <- best_model
summary(final_model)
summary(m)
# Function to create outlier regressors
create_outlier_regressors <- function(y, idx) {
n <- length(y)
AO <- rep(0, n)
AO[idx] <- 1
LS <- rep(0, n)
LS[idx:n] <- 1
TC <- rep(0, n)
decay <- 0.7
TC[idx:n] <- decay^(0:(n - idx))
return(list(AO = AO, LS = LS, TC = TC))
}
# Function to select best outlier type based on AIC
select_best_outlier <- function(y, Xreg, idx) {
outlier_regs <- create_outlier_regressors(y, idx)
AIC_values <- c()
models <- list()
for (type in names(outlier_regs)) {
Xreg_new <- cbind(Xreg, outlier_regs[[type]])
colnames(Xreg_new)[ncol(Xreg_new)] <-paste0( type,floor(time(y)[idx]), ".", month.abb[cycle(y)[idx]])
model <- arima(y, xreg = Xreg_new, order = c(0,1,1), seasonal = c(0,1,1), method = 'ML')
AIC_values[type] <- AIC(model)
models[[type]] <- model
}
best_type <- names(which.min(AIC_values))
best_model <- models[[best_type]]
best_regressor <- outlier_regs[[best_type]]
return(list(type = best_type, model = best_model, regressor = best_regressor))
}
# Initialize variables
Xreg_current <- Xreg
outlier_positions <- outliers
outlier_types <- c()
iteration <- 1
threshhold <- 2.5
# Iterative outlier detection and correction
while(length(outlier_positions) > 0) {
print(paste("Iteration", iteration))
# Get the position of the largest outlier
idx <- outlier_positions[which.max(abs(std_residuals[outlier_positions]))]
year <- floor(time(y)[idx])
month_index <- cycle(y)[idx]
month_name <- month.abb[month_index]
print(paste("Processing outlier at time", year, month_name))
# Select best outlier type
best_outlier <- select_best_outlier(y, Xreg_current, idx)
best_type <- best_outlier$type
best_model <- best_outlier$model
best_regressor <- best_outlier$regressor
print(paste("Selected outlier type:", best_type))
# Update regressors
Xreg_current <- cbind(Xreg_current, best_regressor)
colnames(Xreg_current)[ncol(Xreg_current)] <- paste0(best_type,floor(time(y)[idx]), ".", month.abb[cycle(y)[idx]])
outlier_types <- c(outlier_types, paste0(best_type,floor(time(y)[idx]), ".", month.abb[cycle(y)[idx]]))
# Recalculate standardized residuals
residuals <- residuals(best_model)
std_residuals <- residuals / sqrt(best_model$sigma2)
# Plot standardized residuals
plot(std_residuals, type = 'o', main = paste("Standardized Residuals after iteration ", iteration), xlab = "Time", ylab = "Standardized Residuals")
abline(h = c(-threshhold, threshhold), col = "red")
# Identify outliers
outlier_positions <- which(abs(std_residuals) > threshhold)
outlier_positions <- setdiff(outlier_positions, idx)  # Exclude already processed outlier
if(length(outlier_positions) > 0){
print("Outliers detected at positions:")
for (idx_new in outlier_positions) {
year_new <- floor(time(y)[idx_new])
month_index_new <- cycle(y)[idx_new]
month_name_new <- month.abb[month_index_new]
print(paste("Time:", year_new, month_name_new, "Residual:", std_residuals[idx_new]))
}
} else {
print("No more outliers detected.")
}
iteration <- iteration + 1
}
# Final model
final_model <- best_model
summary(final_model)
summary(m)
install.packages("broom")
# Final model
library(broom)
final_model <- best_model
print(tid(final_model))
# Final model
library(broom)
final_model <- best_model
print(tidy(final_model))
print(tidy(m))
# Final model
library(broom)
final_model <- best_model
print(tidy(final_model))
print(m)
# Final model
library(broom)
final_model <- best_model
print(tidy(final_model))
summary(m)
?tidy
# Final model
library(broom)
final_model <- best_model
summary(final_model)
summary(m)
library(forecast)
library(DiagrammeR)
library(DiagrammeRsvg)
# Creating the flowchart
flowchart_script <- '
digraph TRAMO_Workflow {
// Graph layout direction
rankdir=TB;
node [fontname = Arial, shape = box, style = filled, color = grey, fontsize = 14, fontcolor = black, width = 1.5, height = 0.5]
edge [color = black, arrowhead = vee, arrowsize = 1]
// Define subgraphs for alignment
subgraph cluster_main {
style=invis;
input [label = "Univariate Time Series, \nmonthly/quarterly/annual"]
transformation [label = "Applies/Tests for \nLog/Level transformation"]
specialeffect [label = "Pretests for Trading Day \nand Easter effects"]
regression[label = "Performs regression with ARIMA noise \nUser Given Regressors, Trading Day, \nEaster Effect, Outlier Variables"]
outliers[label = "Detects outliers one \nby one using t-tests"]
missingvalue [label = "Corrects for missing values \nusing Kalman Filters"]
output[label = "Final Linearized Series, \nInput for SEATS"]
}
subgraph cluster_model {
style=invis;
finalmodel [label = "Final ARIMA\n model", shape = ellipse, color = "lightcoral"]
}
subgraph cluster_user {
style=invis;
UserRegressors [label = "User given\n Regressors", shape = ellipse, color = "lightcyan"]
}
// Connections
input -> transformation
transformation -> specialeffect
specialeffect -> regression
UserRegressors ->  regression [dir=forward]
regression -> outliers
outliers -> missingvalue
outliers -> finalmodel [dir=forward]
outliers -> regression
missingvalue -> output
}
'
graph <- DiagrammeR::grViz(flowchart_script)
# Export to SVG
svg <- DiagrammeRsvg::export_svg(graph)
writeLines(svg, "flowchart.svg")
library(seasonal)
library(forecast)
plot(AirPassengers)
m <- seas((AirPassengers), seats = NULL)
summary(m)
tramo_output <- series(m, "ref")[,'Reg.Resids']
plot(tramo_output)
lines(log(AirPassengers), col = 'darkgreen' )
legend("bottomright", legend = c("Tramo Output", "Log(AirPassangers)"),lwd= 1, col = c("black", "darkgreen"))
plot(log(AirPassengers) - tramo_output, main = "Adjustments to the log series")
y <- log(AirPassengers)
regression_matrix <- series(m, "regression.regressionmatrix")
print(colnames(regression_matrix))
x_easter = regression_matrix[, 'Easter.1.']
print(x_easter)
trading_day_regressors <- regression_matrix[,'Weekday']
print((trading_day_regressors[1:48]))
calculate_td_values <- function(year) {
results <- numeric(12)
for (month in 1:12) {
# Determine the start and end dates for the month
start_date <- as.Date(paste(year, month, "01", sep = "-"))
# Handle December we transition to the next year
if (month == 12) {
end_date <- as.Date(paste(year + 1, "01", "01", sep = "-")) - 1
} else {
end_date <- as.Date(paste(year, month + 1, "01", sep = "-")) - 1
}
dates <- seq.Date(start_date, end_date, by = "day")
# Calculate the number of each weekday in the month
mondays <- sum(weekdays(dates) == "Monday")
tuesdays <- sum(weekdays(dates) == "Tuesday")
wednesdays <- sum(weekdays(dates) == "Wednesday")
thursdays <- sum(weekdays(dates) == "Thursday")
fridays <- sum(weekdays(dates) == "Friday")
saturdays <- sum(weekdays(dates) == "Saturday")
sundays <- sum(weekdays(dates) == "Sunday")
results[month] <- (mondays + tuesdays + wednesdays + thursdays + fridays) - (5/2) * (saturdays + sundays)
}
return(results)
}
month_values1949 <- calculate_td_values(1949)
month_values1950 <- calculate_td_values(1950)
month_values1951 <- calculate_td_values(1951)
month_values1952 <- calculate_td_values(1952)
print(month_values1949)
print(month_values1950)
print(month_values1951)
print(month_values1952)
Xreg = matrix(c(trading_day_regressors[1:144], x_easter[1:144]), ncol = 2)
pretest0 <- Arima(y,  order = c(0,1,1), seasonal = c(0,1,1))
pretest <- Arima(y,xreg = Xreg,  order = c(0,1,1), seasonal = c(0,1,1))
print(pretest0)
print(pretest)
# Initial model with regressors (Easter and trading day effects)
model_with_regressors <- Arima(y, xreg = Xreg, order = c(0,1,1), seasonal = c(0,1,1), method = 'ML')
# Calculate standardized residuals
residuals <- residuals(model_with_regressors)
std_residuals <- residuals / sqrt(model_with_regressors$sigma2)
# Plot standardized residuals
plot(std_residuals, type = 'o', main = "Standardized Residuals", xlab = "Time", ylab = "Standardized Residuals")
abline(h = c(-3, 3), col = "red")
# Identify outliers (standardized residuals > 3 in absolute value)
outliers <- which(abs(std_residuals) > 3)
if(length(outliers) > 0){
cat("Outliers detected at positions:\n")
for (idx in outliers) {
year <- floor(time(y)[idx])
month_index <- cycle(y)[idx]
month_name <- month.abb[month_index]
cat(sprintf("Time: %d %s, Residual: %f\n", year, month_name, std_residuals[idx]))
}
} else {
cat("No outliers detected.\n")
}
# Function to create outlier regressors
create_outlier_regressors <- function(y, idx) {
n <- length(y)
AO <- rep(0, n)
AO[idx] <- 1
LS <- rep(0, n)
LS[idx:n] <- 1
TC <- rep(0, n)
decay <- 0.7
TC[idx:n] <- decay^(0:(n - idx))
return(list(AO = AO, LS = LS, TC = TC))
}
# Function to select best outlier type based on AIC
select_best_outlier <- function(y, Xreg, idx) {
outlier_regs <- create_outlier_regressors(y, idx)
AIC_values <- c()
models <- list()
for (type in names(outlier_regs)) {
Xreg_new <- cbind(Xreg, outlier_regs[[type]])
colnames(Xreg_new)[ncol(Xreg_new)] <-paste0( type,floor(time(y)[idx]), ".", month.abb[cycle(y)[idx]])
model <- Arima(y, xreg = Xreg_new, order = c(0,1,1), seasonal = c(0,1,1), method = 'ML')
AIC_values[type] <- AIC(model)
models[[type]] <- model
}
best_type <- names(which.min(AIC_values))
best_model <- models[[best_type]]
best_regressor <- outlier_regs[[best_type]]
return(list(type = best_type, model = best_model, regressor = best_regressor))
}
# Initialize variables
Xreg_current <- Xreg
outlier_positions <- outliers
outlier_types <- c()
iteration <- 1
threshhold <- 2.5
# Iterative outlier detection and correction
while(length(outlier_positions) > 0) {
print(paste("Iteration", iteration))
# Get the position of the largest outlier
idx <- outlier_positions[which.max(abs(std_residuals[outlier_positions]))]
year <- floor(time(y)[idx])
month_index <- cycle(y)[idx]
month_name <- month.abb[month_index]
print(paste("Processing outlier at time", year, month_name))
# Select best outlier type
best_outlier <- select_best_outlier(y, Xreg_current, idx)
best_type <- best_outlier$type
best_model <- best_outlier$model
best_regressor <- best_outlier$regressor
print(paste("Selected outlier type:", best_type))
# Update regressors
Xreg_current <- cbind(Xreg_current, best_regressor)
colnames(Xreg_current)[ncol(Xreg_current)] <- paste0(best_type,floor(time(y)[idx]), ".", month.abb[cycle(y)[idx]])
outlier_types <- c(outlier_types, paste0(best_type,floor(time(y)[idx]), ".", month.abb[cycle(y)[idx]]))
# Recalculate standardized residuals
residuals <- residuals(best_model)
std_residuals <- residuals / sqrt(best_model$sigma2)
# Plot standardized residuals
plot(std_residuals, type = 'o', main = paste("Standardized Residuals after iteration ", iteration), xlab = "Time", ylab = "Standardized Residuals")
abline(h = c(-threshhold, threshhold), col = "red")
# Identify outliers
outlier_positions <- which(abs(std_residuals) > threshhold)
outlier_positions <- setdiff(outlier_positions, idx)  # Exclude already processed outlier
if(length(outlier_positions) > 0){
print("Outliers detected at positions:")
for (idx_new in outlier_positions) {
year_new <- floor(time(y)[idx_new])
month_index_new <- cycle(y)[idx_new]
month_name_new <- month.abb[month_index_new]
print(paste("Time:", year_new, month_name_new, "Residual:", std_residuals[idx_new]))
}
} else {
print("No more outliers detected.")
}
iteration <- iteration + 1
}
# Final model
library(broom)
final_model <- best_model
summary(final_model)
summary(m)
# Final model
library(broom)
final_model <- best_model
print(summary(final_model))
print(summary(m))
Xreg_current
Xreg
matrix("Weekday"= trading_day_regressors[1:144],"Easter"= x_easter[1:144])
Xreg = cbind("Weekday" =  trading_day_regressors[1:144],"Easter"= x_easter[1:144])
pretest0 <- Arima(y,  order = c(0,1,1), seasonal = c(0,1,1))
pretest <- Arima(y,xreg = Xreg,  order = c(0,1,1), seasonal = c(0,1,1))
print(pretest0)
print(pretest)
library(seasonal)
library(forecast)
plot(AirPassengers)
m <- seas((AirPassengers), seats = NULL)
summary(m)
tramo_output <- series(m, "ref")[,'Reg.Resids']
plot(tramo_output)
lines(log(AirPassengers), col = 'darkgreen' )
legend("bottomright", legend = c("Tramo Output", "Log(AirPassangers)"),lwd= 1, col = c("black", "darkgreen"))
plot(log(AirPassengers) - tramo_output, main = "Adjustments to the log series")
?Arima()
# Initial model with regressors (Easter and trading day effects)
model_with_regressors <- Arima(y, xreg = Xreg, order = c(0,1,1), seasonal = c(0,1,1), method = 'ML')
# Calculate standardized residuals
residuals <- residuals(model_with_regressors)
std_residuals <- residuals / sqrt(model_with_regressors$sigma2)
# Plot standardized residuals
plot(std_residuals, type = 'o', main = "Standardized Residuals", xlab = "Time", ylab = "Standardized Residuals")
abline(h = c(-3, 3), col = "red")
# Identify outliers (standardized residuals > 3 in absolute value)
outliers <- which(abs(std_residuals) > 3)
if(length(outliers) > 0){
cat("Outliers detected at positions:\n")
for (idx in outliers) {
year <- floor(time(y)[idx])
month_index <- cycle(y)[idx]
month_name <- month.abb[month_index]
cat(sprintf("Time: %d %s, Residual: %f\n", year, month_name, std_residuals[idx]))
}
} else {
print("No outliers detected")
}
# Initial model with regressors (Easter and trading day effects)
model_with_regressors <- Arima(y, xreg = Xreg, order = c(0,1,1), seasonal = c(0,1,1), method = 'ML')
# Calculate standardized residuals
residuals <- residuals(model_with_regressors)
std_residuals <- residuals / sqrt(model_with_regressors$sigma2)
# Plot standardized residuals
plot(std_residuals, type = 'o', main = "Standardized Residuals", xlab = "Time", ylab = "Standardized Residuals")
abline(h = c(-3, 3), col = "red")
# Identify outliers (standardized residuals > 3 in absolute value)
outliers <- which(abs(std_residuals) > 3)
if(length(outliers) > 0){
cat("Outliers detected at positions:\n")
for (idx in outliers) {
year <- floor(time(y)[idx])
month_index <- cycle(y)[idx]
month_name <- month.abb[month_index]
print(paste("Time:", year, month_name, "Residual:", std_residuals[idx]))
}
} else {
print("No outliers detected")
}
setwd("~/Documents/Projects/X-13-ARIMA-SEATS-Model-for-Seasonal-Adjustment")
